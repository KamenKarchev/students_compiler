14. ВИРТУАЛНА МАШИНА. ГЕНЕРИРАНЕ НА ИНСТРУКЦИИ ЗА ВИРТУАЛНАТА
МАШИНА
Цел на упражнението
Упражнението представя виртуалната машина, за която компилаторът генерира код. Описана
е структурата на машината. Обяснена е структурата на стеков кадър. Показани са инструкциите,
които се генерират за примерни входни програми.
14.1. Структура
Виртуалната машина е абстрактна изчислителна машина. Също както реална машина, тя
изпълнява множество от инструкции. Виртуалната машина е независима от входния език на
компилираната програма.
Тъй като виртуалната машина е създадена за учебни цели, нейните инструкции и операнди се
представят с кодове от целочислен тип.
Процесорът на виртуалната машина има следната структура:
 програмен брояч;
 стек;
 памет за динамични данни (heap).
За реализация на виртуалната машина са използвани следните структури от данни:
 масив от инструкции – съдържа кодовете на генерираните инструкции в числов вид;
 операнден стек – съдържа стойностите на операндите за изпълнение на съответните
инструкции;
 стек от кадри (frames) – при всяко извикване на функция се създава нов стеков кадър. В
кадъра се съдържа адрес за връщане и масив от локални променливи. При излизане от
функцията стековият кадър се унищожава;
 масив за глобални променливи – съдържа глобални променливи, които са достъпни във
всяка точка от програмата;
 heap – използва се за съхранение на динамично създадени масиви. Реализира се като масив
от масиви.
14.2. Стеков кадър
На входа на генератора се получава семантично коректно дърво и символната таблица. На
базата на тези структури той формира инструкции за изпълнение от виртуалната машина.
Програмният модел на виртуалната машина включва три регистъра: програмен брояч,
указател на върха на стека и базов указател. Стекът се използва за изчислителни цели и за
осъществяване на обръщения към функции. Входният език има блокова структура, която изисква
динамично разпределение на паметта. При влизане във всеки блок в стека на виртуалната машина
се създава фрагмент, наречен стеков кадър, който съдържа указатели към извиквания и обхващащия
блок и паметта за локалните променливи (фиг 14.1).
74
Фиг. 14. 1. Структура на стеков кадър за изпълнение на подпрограма
Базовият указател (BP) сочи началото на стековия кадър за извикването на дадена функция.
Адресацията в рамките на този кадър е относителна спрямо базовия указател. Първата клетка в
кадъра (dynamic) съдържа адреса на извикващата функция. В static се съхранява адрес на
непосредствено обхващащата функция, а link съдържа адрес на връщане след изпълнението на
извиканата функция. След тези три адреса се разполага памет за всички декларирани във функцията
променливи. Изчислителният стек се използва за изпълнение на операциите в тялото на функцията.
В края на изпълнението на функцията стековият кадър за нея се унищожава, а управлението се връща
на ивикващата функция на адрес, определен от link.
14.3. Примери за генерирани иструкции за виртуалната машина
Пример 1. Програма, която извежда символния низ “Hello!”.
program {
 main() -> void {
 print("Hello");
 }
}
Генерираните инструкции се извеждат в следния формат:
Относителен адрес: мнемонично име : [операнд]
Полето операнд не е задължително, защото има инструкции без операнди, напр. PRINT,
HALT. Операндът може да бъде адрес на преход към следваща инструкция или символ, който се
записва във върха на стека. Подробно описание на всички инструкции е дадено в приложение Г.
За програмата от пример 1 компилаторът генерира следните инструкции.
0: GOTO : 2 /* Преход към адрес 2* /
2: ICONST : 6 /* Запис на целочислена константа */
75
4: NEWARRAY : 1 /* Създаване на масив */
6: ICONST : 72 /* ASCII код на символ ‘H’ */
8: ICONST : 101 /*ASCII код на символ e */
10: ICONST : 108 /* ASCII код на символ l */
12: ICONST : 108 /* ASCII код на символ l */
14: ICONST : 111 /* ASCII код на символ o */
16: ICONST : 33 /* ASCII код на символ ! */
18: ICONST : 6 /* ASCII код на символ ACK */
20: CASTOREALL : /* Запис на стойности в масив от символи */
21: ICONST : 3
23: ICONST : 1
25: PRINT : /* Извеждане на резултат */
26: HALT : /* Спиране на виртуалната машина */
Показаните генерирани инструкции записват последователно ASCII кодовете на символите
във върха на стека. Инструкцията CASTTOREALL прехвърля символите от стека в масив.
Инструкцията PRINT извежда символния масив на стандартния изход.
Пример 2. Програма, която изчислява сума на две цели числа чрез функция.
program {
 sum(int a, int b) -> int {
 return a + b;
 }
 main() -> void {
 print(@sum(10, 5));
 }
}
0: GOTO : 8 /* Преход към адрес 8* /
2: ILOAD : 0 /* Запис в стека на първи формален параметър */
4: ILOAD : 1 /* Запис в стека на втори формален параметър */
6: IADD : /* Събиране на операнди */
7: IRETURN : /* Връщане на резултат от функцията */
8: GOTO : 10 /* Преход към извикващата функция */
10: ICONST : 10 /* Запис в стека на първи актуален параметър */
12: ICONST : 5 /* Запис в стека на втори актуален параметър */
14: ICONST : 2 /* Запис в стека на адрес на функция */
16: CALL : 2 /* Извикване на функция */
18: ICONST : 0
20: ICONST : 1
22: PRINT : /* Извеждане на резултат */
23: HALT : /* Спиране на виртуалната машина */
Показаните генерирани инструкции записват в стека адресите на двата формални параметъра,
с които е дефинирана функцията sum. Инструкцията IADD изпълнява операция събиране на два
целочислени операнда, прочетени от стека. IRETURN връща резултат от функцията sum, а GOTO
прави преход към извикващата функция main. С две последователни инструкции ICONST се
записват в стека стойностите на актуалните (фактическите) параметри, с които се извиква функцията
sum. Инструкцията CALL прави преход към извиканата функция sum.
76
14.4. Файлове на генератора на код
Алгоритъмът за генериране на код е реализиран в клас CodeGenerator. Програмната
реализация на класа е във файла CodeGenerator.java в поддиректорията code_gen на проекта.
Реализацията на методите за генериране на инструкции е дадена в приложение Д.
Контролни въпроси
1. Какви са предимствата и недостатъците при използване на виртуална машина?
2. Опишете структурата на виртуалната машина, използвана от учебния компилатор.
3. Обяснете предназначението и структурата на стековия кадър.
Задачи
1. Като използвате описанието на инструкциите на виртуалната машина в приложение Г, съставете
инструкции за умножение на две цели числа чрез функция.
2. Да се генерира код за следните програми на STUDENT:
а) Програма, която извежда на екран низ “Hello, world!”;
б) Програма, която извежда сумата на целите числа от 1 до 10;
в) Програма, която извежда стойността на факториел за число, подадено като параметър на функция,
като се използва рекурсивен алгоритъм;
г) Програма, която извежда стойността на факториел за число, подадено като параметър на функция,
като се използва итеративен алгоритъм;
д) Програма, която изчислява и извежда сумата на числата в масив от 10 цели числа;
е) Програма, която сортира масив от 10 цели числа във възходящ ред;
ж) Програма, която намира най-голямото число в масив от 10 цели числа;
з) Програма за търсене на число, въведено от стандартния вход, в масив от 10 цели числа.
77
ПРИЛОЖЕНИЕ А. РЕЗУЛТАТИ ОТ ТРАНСЛИРАНЕ НА ВХОДНА ПРОГРАМА
Проведените тестове са демонстрирани с класическа задача за намиране на n-тото число на
Фибоначи с използване на рекурсивен подход (с мемоизация). Тази задача е избрана с цел
резултатите от отделните етапи на тестването да не бъдат твърде дълги. От друга страна задачата
позволява тестване на множество функционалности във входния език.
А.1. Входна програма
program {
 int num = 35;
 int[] memo = int[num];
 fib(int num) -> int {
 if (memo[num] != 0) {
 return memo[num];
 }
 if (num == 0) { return 0; }
 if (num < 2) { return 1; }
 int res = @fib(num - 1) + @fib(num - 2);
 memo[num] = res;
 return res;
 }
 main() -> void {
 print(num, "fibonacci number is:", @fib(num), '\n');
 }
}
А.2. Лексеми, формирани от лексическия анализатор
[ PROGRAM ] : program
[ LBRACKET ] : {
[ INT ] : int
[ IDENTIFIER ] : num
[ BECOMES ] : =
[ NUMBER ] : 35
[ SEMICOLON ] : ;
[ INT ] : int
[ LSQUARE ] : [
[ RSQUARE ] : ]
[ IDENTIFIER ] : memo
[ BECOMES ] : =
[ INT ] : int
[ LSQUARE ] : [
[ IDENTIFIER ] : num
[ RSQUARE ] : ]
[ SEMICOLON ] : ;
[ IDENTIFIER ] : fib
[ LPAREN ] : (
78
[ INT ] : int
[ IDENTIFIER ] : num
[ RPAREN ] :
)
[ ARROW ] :
-
>
[ INT ] : int
[ LBRACKET ] :
{
[ IF ] : if
[ LPAREN ] :
(
[ IDENTIFIER ] : memo
[ LSQUARE ] :
[
[ IDENTIFIER ] : num
[ RSQUARE ] :
]
[ NOTEQUALS ] : !=
[ NUMBER ] :
0
[ RPAREN ] :
)
[ LBRACKET ] :
{
[ RETURN ] : return
[ IDENTIFIER ] : memo
[ LSQUARE ] :
[
[ IDENTIFIER ] : num
[ RSQUARE ] :
]
[ SEMICOLON ] :
;
[ RBRACKET ] :
}
[ IF ] : if
[ LPAREN ] :
(
[ IDENTIFIER ] : num
[ EQUALS ] : ==
[ NUMBER ] :
0
[ RPAREN ] :
)
[ LBRACKET ] :
{
[ RETURN ] : return
[ NUMBER ] :
0
[ SEMICOLON ] :
;
[ RBRACKET ] :
}
[ IF ] : if
[ LPAREN ] :
(
[ IDENTIFIER ] : num
[ LESS ] :
<
[ NUMBER ] :
2
[ RPAREN ] :
)
[ LBRACKET ] :
{
[ RETURN ] : return
[ NUMBER ] :
1
[ SEMICOLON ] :
;
[ RBRACKET ] :
}
[ INT ] : int
[ IDENTIFIER ] : res
[ BECOMES ] :
=
[ AT ] :
@
[ IDENTIFIER ] : fib
[ LPAREN ] :
(
79
[ IDENTIFIER ] : num
[ MINUS ] : -
[ NUMBER ] : 1
[ RPAREN ] : )
[ PLUS ] : +
[ AT ] : @
[ IDENTIFIER ] : fib
[ LPAREN ] : (
[ IDENTIFIER ] : num
[ MINUS ] : -
[ NUMBER ] : 2
[ RPAREN ] : )
[ SEMICOLON ] : ;
[ IDENTIFIER ] : memo
[ LSQUARE ] : [
[ IDENTIFIER ] : num
[ RSQUARE ] : ]
[ BECOMES ] : =
[ IDENTIFIER ] : res
[ SEMICOLON ] : ;
[ RETURN ] : return
[ IDENTIFIER ] : res
[ SEMICOLON ] : ;
[ RBRACKET ] : }
[ IDENTIFIER ] : main
[ LPAREN ] : (
[ RPAREN ] : )
[ ARROW ] : ->
[ VOID ] : void
[ LBRACKET ] : {
[ PRINT ] : print
[ LPAREN ] : (
[ IDENTIFIER ] : num
[ COMMA ] : ,
[ STRING_LITERAL ] : fibonacci number is:
[ COMMA ] : ,
[ AT ] : @
[ IDENTIFIER ] : fib
[ LPAREN ] : (
[ IDENTIFIER ] : num
[ RPAREN ] : )
[ COMMA ] : ,
[ CHAR_LITERAL ] : \n
[ RPAREN ] : )
[ SEMICOLON ] : ;
[ RBRACKET ] : }
[ RBRACKET ] : }
80
А.3. Абстрактно синтактично дърво, построено от синтактичния анализатор
<program>
<variable definition>
<type: int >
</type: int>
<assignment>
<variable: num>
</variable: num>
<int 35>
</int 35>
</assignment>
</variable definition>
<variable definition>
<type: int[] >
</type: int[]>
<assignment>
<variable: memo>
</variable: memo>
<array initialization>
<variable: num>
</variable: num>
</array initialization>
</assignment>
</variable definition>
<function: fib>
<formal parameters>
<typed variable>
<type: int >
</type: int>
<variable: num>
</variable: num>
</typed variable>
</formal parameters>
<type: int >
</type: int>
<block>
<if>
<not equal>
<indexed variable: memo>
<variable: num>
</variable: num>
</indexed variable: memo>
<int 0>
</int 0>
</not equal>
<block>
<return>
<indexed variable: memo>
<variable: num>
</variable: num>
81
</indexed variable: memo>
</return>
</block>
</if>
<if>
<equals>
<variable: num>
</variable: num>
<int 0>
</int 0>
</equals>
<block>
<return>
<int 0>
</int 0>
</return>
</block>
</if>
<if>
<less>
<variable: num>
</variable: num>
<int 2>
</int 2>
</less>
<block>
<return>
<int 1>
</int 1>
</return>
</block>
</if>
<variable definition>
<type: int >
</type: int>
<assignment>
<variable: res>
</variable: res>
<addition>
<function call: fib>
<actual parameters>
<subtraction>
<variable: num>
</variable: num>
<int 1>
</int 1>
</subtraction>
</actual parameters>
</function call: fib>
<function call: fib>
<actual parameters>
82
<subtraction>
<variable: num>
</variable: num>
<int 2>
</int 2>
</subtraction>
</actual parameters>
</function call: fib>
</addition>
</assignment>
</variable definition>
<assignment>
<indexed variable: memo>
<variable: num>
</variable: num>
</indexed variable: memo>
<variable: res>
</variable: res>
</assignment>
<return>
<variable: res>
</variable: res>
</return>
</block>
</function: fib>
<function: main>
<void>
</void>
<block>
<print>
<actual parameters>
<variable: num>
</variable: num>
<string literal>
</string literal>
<function call: fib>
<actual parameters>
<variable: num>
</variable: num>
</actual parameters>
</function call: fib>
<char literal>
</char literal>
</actual parameters>
</print>
</block>
</function: main>
</program>
83
А.4. Генериран код за изпълнение от виртуалната машина
0,35,7,0,1,0,37,0,7,1,31,79,1,1,2,0,4,0,0,24,30,28,1,1,2,0,4,32,2,0,0,0,23,30,38,0,0,32,2,0,0,2,25,30,48,0,1,
32,2,0,0,1,15,0,1,35,12,2,0,0,2,15,0,1,35,12,14,8,1,1,1,2,0,2,1,10,2,1,32,1,0,0,0,0,20,37,1,0,102,0,105,0,98
,0,111,0,110,0,97,0,99,0,99,0,105,0,32,0,110,0,117,0,109,0,98,0,101,0,114,0,32,0,105,0,115,0,58,0,20,13,
0,3,1,0,0,1,35,12,0,0,0,10,0,1,0,4,39,36
А.5. Генериран код, представен във формат, използван при debug
0: ICONST 35
2: GSTORE 0
4: GLOAD 0
6: NEWARRAY 0
8: GSTORE 1
10: GOTO 79
12: GLOAD 1
14: ILOAD 0
16: IALOAD
17: ICONST 0
19: ICMPNE
20: IF_FALSE 28
22: GLOAD 1
24: ILOAD 0
26: IALOAD
27: IRETURN
28: ILOAD 0
30: ICONST 0
32: ICMPEQ
33: IF_FALSE 38
35: ICONST 0
37: IRETURN
38: ILOAD 0
40: ICONST 2
42: ICMPLT
43: IF_FALSE 48
45: ICONST 1
47: IRETURN
48: ILOAD 0
50: ICONST 1
52: ISUB
53: ICONST 1
55: CALL 12
57: ILOAD 0
59: ICONST 2
61: ISUB
62: ICONST 1
64: CALL 12
66: IADD
67: ISTORE 1
69: GLOAD 1
84
71: ILOAD 0
73: ILOAD 1
75: IASTORE
76: ILOAD 1
78: IRETURN
79: GLOAD 0
81: ICONST 0
83: ICONST 20
85: NEWARRAY 1
87: ICONST 102
89: ICONST 105
91: ICONST 98
93: ICONST 111
95: ICONST 110
97: ICONST 97
99: ICONST 99
101: ICONST 99
103: ICONST 105
105: ICONST 32
107: ICONST 110
109: ICONST 117
111: ICONST 109
113: ICONST 98
115: ICONST 101
117: ICONST 114
119: ICONST 32
121: ICONST 105
123: ICONST 115
125: ICONST 58
127: ICONST 20
129: CASTOREALL
130: ICONST 3
132: GLOAD 0
134: ICONST 1
136: CALL 12
138: ICONST 0
140: ICONST 10
142: ICONST 1
144: ICONST 4
146: PRINT
147: HALT
А.6. Резултат от интерпретирането на генерирания код
35 fibonacci number is: 9227465
85
ПРИЛОЖЕНИЕ Б. ЛЕКСИКА НА ЕЗИКА STUDENT
Ключови думи
Име на лексемата в компилатора Низ на лексемата
IF 'if'
INT 'int'
CHAR 'char'
ELSE 'else'
READ 'read'
TRUE 'true'
VOID 'void'
FALSE 'false'
WHILE 'while'
PRINT 'print'
LENGTH 'length'
RETURN 'return'
BOOLEAN 'boolean'
PROGRAM 'program'
Оператори
Име на лексемата в компилатора Низ на лексемата
PLUS '+'
MINUS '-'
MUL '*'
DIV '/'
MOD '%'
BECOMES '='
Релационни оператори
Име на лексемата в компилатора Низ на лексемата
NOT '!'
EQUALS '=='
NOTEQUALS '!='
GREATER '>'
LESS '<'
GREATER_EQ '>='
LESS_EQ '<='
Логически оператори
Име на лексемата в компилатора Низ на лексемата
AND '&&'
OR '||'
86
Разделители
Име на лексемата в компилатора Низ на лексемата
LSQUARE '['
RSQUARE ']'
LBRACKET '{'
RBRACKET '}'
LPAREN '('
RPAREN ')'
SEMICOLON ';'
COMMA ','
SINGLE_QUOTE '''
DOUBLE_QUOTES '"'
ARROW '->'
AT '@'
Целочислени, булеви и символни константи
Име на лексемата в компилатора Низ на лексемата
INT_LITERAL '0' | [1-9]{1}[0-9]*
CHAR_LITERAL всеки ASCII символ
BOOLEAN_LITERAL 'true' | 'false'
Идентификатор
Име на лексемата в компилатора Низ на лексемата
IDENTIFIER [A-Za-z]{1}[A-Za-z0-9]*
87
ПРИЛОЖЕНИЕ В. СИНТАКСИС НА ЕЗИКА STUDENT
(1) program : PROGRAM LBRACKET program_body RBRACKET
(2) program_body : ( variable_definition SEMICOLON | function_definition )* main_function
(3) main_function : 'main' LPAREN RPAREN ARROW VOID block
(4) function_definition : IDENTIFIER LPAREN ( formal_parameters )? RPAREN ARROW ( VOID | type
) block
(5) formal_parameters : type IDENTIFIER ( COMMA type IDENTIFIER )*
(6) type : primitive_type | array_type
(7) primitive_type : INT | CHAR | BOOLEAN
(8) array_type : primitive_type LSQUARE RSQUARE
(9) block : LBRACKET ( statement )* RBRACKET
(10) statement : simple_statement SEMICOLON | compound_statement
(11) simple_statement : variable_definition | assignment | function_call | return_statement | print_statement
| read_statement
(12) compound_statement : if_statement | while_statement
(13) variable_definition : type assignment
(14) assignment : variable BECOMES assignable
(15) function_call : AT IDENTIFIER LPAREN ( actual_parameters )? RPAREN
(16) return_statement : RETURN ( assignable )?
(17) print_statement : PRINT LPAREN assignable ( COMMA assignable )* RPAREN
(18) read_statement : READ LPAREN variable ( COMMA variable )* RPAREN
(19) if_statement : IF LPAREN expression RPAREN block | IF LPAREN expression RPAREN block
ELSE block
(20) while_statement : WHILE LPAREN expression RPAREN block
(21) actual_parameters : assignable ( COMMA assignable )*
(22) assignable : array_initialization | character_literal | string_literal | expression
(23) array_initialization : primitive_type LSQUARE expression RSQUARE
88
(24) character_literal : SINGLE_QUOTE CHAR_LITERAL SINGLE_QUOTE
(25) string_literal : DOUBLE_QUOTES ( CHAR_LITERAL )* DOUBLE_QUOTES
(26) expression : simple_expression | simple_expression relational_operator simple_expression
(27) simple_expression : signed_term ( ( additive_operator | OR ) signed_term )*
(28) signed_term : (unary_operator)? term
(29) term : factor ( ( multiplicative_operator | AND ) factor )*
(30) factor : variable |
INT_LITERAL | BOOLEAN_LITERAL | LPAREN expression RPAREN |
function_call | array_length
(31) relational_operator : EQUAL | NOT_EQUAL | GREATER_THAN | LESS_THAN
GREATER_THAN_OR_EQUAL | LESS_THAN_OR_EQUAL
(32) unary_operator : NOT | MINUS
(33) additive_operator : PLUS | MINUS
(34) multiplicative_operator : MUL | DIV | MOD
(35) variable : IDENTIFIER | index_variable
(36) index_variable : IDENTIFIER LSQUARE simple_expression RSQUARE
(37) array_length : LENGTH LPAREN variable RPAREN
89
ПРИЛОЖЕНИЕ Г. ИНСТРУКЦИИ НА ВИРТУАЛНАТА МАШИНА
Инструкциите са представени в следния вид:
Име на полето Описание на полето
Мнемоничен код на инструкцията символно име на инструкцията
Код: числов код на инструкцията
Формат: мнемоничен код, операнд1, операнд2, …
Операнден стек: (съдържание на стека преди изпълнение) --> ...
(съдържание на стека след изпълнение)
Описание Описание на инструкцията
Г.1. Операции с константи
 ICONST - записване на целочислена константа в операндния стек.
Код: 0
Формат: iconst, value
Операнден стек: ... --> ..., value
Value трябва да е от целочислен тип. Стойността се записва на върха на операндния стек.
Г.2. Операции за зареждане
 GLOAD - зареждане на стойност от масива с глобални променливи
Код: 1
Формат: gload, index
Операнден стек: ... --> ..., value
Стойността на глобалната променливата, намираща се на index, се записва във върха на
операндния стека.
 ILOAD - зареждане на примитивна стойност от масива с локални променливи
Код: 2
Формат: iload, index
Операнден стек: ... --> ..., value
Стойността на локалната променлива, намираща се на index, се записва на върха на
операндния стек.
 ALOAD - зареждане на референция от масива с локални променливи
Код: 3
Формат: аload, index
Операнден стек: ... --> ..., value
Стойността на локалната променлива, намираща се на index, се записва на върха на
операндния стек.
 IALOAD - зареждане на цяло число от масив
90
Код: 4
Формат: iaload
Операндния стек: ..., arrayref, index --> ..., value
Arrayref трябва да е референция към масив от целочислен тип. Arrayref и index се
премахват от върха на стека. Стойността от целочисления масив, намираща се на позиция index в
масива с референция arrayref, се извлича и се записва на върха на операндния стек.
 BALOAD - зареждане на булева стойност от масив
Код: 5
Формат: baload
Операндния стек: ..., arrayref, index --> ..., value
Arrayref трябва да е референция към масив от булев тип. Arrayref и index се премахват
от върха на стека. Стойността от булевия масив, намираща се на позиция index в масива с
референция arrayref, е се извлича и се записва на върха на операндния стека.
 CALOAD - зареждане на символ от масив
Код: 6
Формат: caload
Операнден стек: ..., arrayref, index --> ..., value
Arrayref трябва да е референция към масив от символен тип. Arrayref и index се
премахват от върха на стека. Стойността от символния масив, намираща се на позиция index в
масива с референция arrayref, се извлича и се записва на върха на операндния стек.
Г.3. Операции за запис на стойности
 GSTORE - записване на стойност в масива с глобални променливи
Код: 7
Формат: gstore, index
Операнден стек: ..., value --> ...
Стойността на върха на операндния стек се премахва и се записва в масива с глобални
променливи на позиция index.
 ISTORE - записване на примитивна стойност в масива с локални променливи
Код: 8
Формат: istore, index
Операнден стек: ..., value --> ...
Стойността на върха на операндния стек се премахва и се записва в масива с локални
променливи на позиция index.
 ASTORE - записване на референция в масива с локални променливи
Код: 9
Формат: astore, index
Операнден стек: ..., value --> ...
91
Стойността на върха на операндния стек се премахва и се записва в масива с локални
променливи на позиция index.
 IASTORE - запазване на стойност в целочислен масив
Код: 10
Формат: iastore
Операнден стек: ..., arrayref, index, value --> ...
Arrayref трябва да е референция към масив от целочислен тип. Value трябва да е от
целочислен тип. Arrayref, index и value се премахват от върха на стека. Целочислената
стойност value се запазва на позиция index в масива с референция arrayref.
 BASTORE - запазване на стойност в булев масив.
Код: 11
Формат: bastore
Операнден стек: ..., arrayref, index, value --> ...
Arrayref трябва да е референция към масив от булев тип. Value трябва да е от булев тип.
Arrayref, index и value се премахват от върха на стека. Булевата стойност value се запазва на
позиция index в масива с референция arrayref.
 CASTORE - запазване на стойност в символен масив
Код: 12
Формат: castore
Операнден стек: ..., arrayref, index, value --> ...
Arrayref трябва да е референция към масив от символен тип. Value трябва да е от символен
тип. Arrayref, index и value се премахват от върха на стека. Символната стойност value се
запазва на позиция index в масива с референция arrayref.
 CASTOREALL - запазване на стойности в символен масив
Код: 13
Формат: castore
Операнден стек: ..., arrayref, value1, …, value n, nargs --> ...
Arrayref трябва да е референция към масив от символен тип. Value1 … value n трябва
да са от символен тип, а nargs е броят на елементите. Arrayref, values и nargs се премахват
от върха на стека. Символните стойности се записват в масива с референция arrayref.
Г.4. Аритметични и логически операции
 IADD - целочислено събиране
Код: 14
Формат: iadd
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стек. Резултатът (result) от операцията е value1 + value2, който се записва на
върха на стека.
92
 ISUB - целочислено изваждане
Код: 15
Формат: isub
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стека. Резултатът (result) от операцията е value1 - value2, който се записва на
върха на стека.
 IMUL - целочислено умножение
Код: 16
Формат: imul
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стека. Резултатът (result) от операцията е value1 * value2, който се записва на
върха на стека.
 IDIV - целочислено деление
Код: 17
Формат: idiv
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стек. Резултатът (result) от операцията е value1 / value2, който се записва на
върха на стека.
 IREM - целочислено деление с остатък
Код: 18
Формат: irem
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стек. Резултатът (result) от операцията е value1 - (value1 / value2) *
value2, който се записва на върха на стека.
 INEG - целочислено отрицание
Код: 19
Формат: ineg
Операнден стек: ..., value --> ..., result
Стойността value трябва да е от целочислен тип. Тя се премахва от операндния стек.
Резултатът (result) от операцията е - value, който се записва на върха на стека.
 IAND - логическо И
Код: 20
Формат: iand
Операнден стек: ..., value1, value2 --> ..., result
93
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стека. Резултатът (result) от операцията е value1 & value2, който се записва на
върха на стека.
 IOR - логическо ИЛИ
Код: 21
Формат: ior
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стек. Резултатът (result) от операцията е value1 | value2, който се записва на
върха на стека.
 NOT - логическо отрицание.
Код: 22
Формат: not
Операнден стек: ..., value --> ..., result
Стойността value трябва да е от булев тип. Тя се премахва от операндния стек. Резултатът
(result) от операцията е value xor 1, който се записва на върха на стека.
Г.5. Операции за сравнение
 ICMPEQ - операция за проверка на еквивалентност
Код: 23
Формат: icmpeq
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стека. Резултатът (result) от операцията value1 == value2 е булев (0 или 1) и се
записва на върха на стека.
 ICMPNE - операция за проверка на нееквивалентност
Код: 24
Формат: icmpne
Операндния стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стек. Резултатът (result) от операцията value1 != value2 е булев (0 или 1) и се
записва на върха на стека.
 ICMPLT - операция проверка за по-малко
Код: 25
Формат: icmplt
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стек. Резултатът (result) от операцията value1 < value2 е булев (0 или 1) и се
записва на върха на стека.
94
 ICMPLE – операция проверка за по-малко или равно
Код: 26
Формат: icmple
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стек. Резултатът (result) от операцията value1 <= value2 е булев (0 или 1) и се
записва на върха на стека.
 ICMPGT - операция проверка за по-голямо
Код: 27
Формат: icmpgt
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стека. Резултатът (result) от операцията value1 > value2 е булев(0 или 1) и се
записва на върха на стека.
 ICMPGE - операция проверка за по – голямо или равно
Код: 28
Формат: icmpge
Операнден стек: ..., value1, value2 --> ..., result
Двете стойности value1 и value2 трябва да са от целочислен тип. Те се премахват от
операндния стека. Резултатът (result) от операцията value1 >= value2 е булев (0 или 1) и се
записва на върха на стека.
 IF_TRUE - условен преход при изпълнено условие (true)
Код: 29
Формат: if_true, address
Операнден стек: ..., value --> ...
Стойността value трябва да е от целочислен тип. Тя се премахва от операндния стек. Ако
value има стойност 1, то програмата продължава с изпълнение на инструкция, намираща се на
address.
 IF_FALSE - условен преход при неизпълнено условие (false)
Код: 30
Формат: if_false, address
Операнден стек: ..., value --> ...
Стойността value трябва да е от булев тип. Тя се премахва от операндния стек. Ако value
има стойност 0, то програмата продължава с изпълнение на инструкция, намираща се на address.
Г.6. Операции за управление
 GOTO - безусловен преход
Код: 31
Формат: goto, address
95
Операнден стек: не се променя
Address трябва да е адрес на инструкция. Изпълнението на програмата продължава на
address.
 IRETURN - връщане на целочислена стойност от функция
Код: 32
Формат: ireturn
Операнден стек: ..., value --> празно
Стойността на value трябва да е от целочислен, булев или символен тип. Тя се премахва от
операндния стек на текущия кадър и се записва на върха на стека на предходния кадър. Текущият
кадър се унищожава, а управлението се връща на предходния кадър.
 ARETURN - връщане на референтна стойност от функция
Код: 33
Формат: areturn
Операнден стек: ..., value --> празно
Стойността на value трябва да е от референтен тип. Тя се премахва от операндния стек на
текущия кадър и се записва на върха на стека на предходния кадър. Текущият кадър се унищожава,
а управлението се връща на предходния кадър.
 RETURN - връщане на void стойност от функция
Код: 34
Формат: return
Операнден стек: ... --> празно
Функцията трябва да връща стойност от тип void. Текущият кадър се унищожава, а
управлението се връща на предходния кадър.
 CALL - извикване на подпрограма
Код: 35
Формат: call, address
Операнден стек: ..., [arg1, [arg2, ... [argn]]], nargs --> ...
Nargs на брой параметри (съответно arg1, arg2, ..., argn) се премахват от операндния стек.
Създава се нов кадър и в масива му от локални промеливи се записват параметрите в съответната
последователност. Изпълнението на програмата продължава на address.
 HALT - прекратяване изпълнението на виртуалната машина
Код: 36
Формат: halt
Операнден стек: без промяна
Г.7. Операции с референтни типове
 NEWARRAY - създаване на масив
Код: 37
Формат: newarray, type
96
Операнден стек: ..., count --> arrayref
Стойността count представя броя на елементите на масива. Тя трябва да е от целочислен тип.
Стойността се премахва от операндния стек. Type представя типа на масива и трябва да е една от
следните целочислени стойности за съответния тип:
int – 0
char – 1
boolean – 2
Масив от тип type и дължина count е алокиран от динамичната памет (heap). Референцията
(arrayref) към този масив се записва на върха на операндния стек.
 ARRAYLENGTH - връща размер на масив
Код: 38
Формат: arraylength
Операнден стек: ..., arrayref --> length
Стойността arrayref трябва да е от референтен тип и да реферира масив. Тя се премахва от
операндния стек. Дължината (length) на реферирания масив се определя и се записва на върха на
операндния стек.
Г.8. Входно-изходни операции
 PRINT - визуализира стойности на стандартния изход
Код: 39
Формат: print
Операнден стек: ..., value1, type1, …, value n, type n, nargs --> …
Value1, type1 … value n, type n са съответно стойности и техните типове, а nargs
е броят на стойностите. Type може да приема следните стойности:
int – 0
char – 1
boolean – 2
string – 3
Value, type се премахват от операндния стек. Стойностите се извеждат на стандартния
изход.
 READ - прочита и записва стойности от стандартния вход
Код: 40
Формат: read
Операнд стек: …, ctx1, index1, type1, ..., ctx n, index n, type n, nargs --> …
Ctx е контекстът, в който се записва текущата прочетената стойност, index е позицията в
контекста, type е типът на стойността, а nargs е броят на стойностите.
Type: Ctx:
int – 0 global – 0
97
char – 1 local – 1
boolean – 2
string – 3
Ctx, index, type, nargs се премахват от операндния стек, а стойностите се записват на
съответната позиция в съответния контекст