# How to Use This Compiler

## Overview
This is a complete compiler for a custom educational programming language that compiles to bytecode and runs on a virtual machine.

## Compiler Pipeline
```
Source Code (.txt) → Lexer → Parser → Semantic Analyzer → Code Generator → Bytecode → VM
```

## Language Features

### Basic Syntax
- **Program structure**: `program { ... }`
- **Data types**: `int`, `char`, `boolean`, `void`
- **Arrays**: `int[]`, `char[]`, `boolean[]`
- **Functions**: `funcName(params) -> returnType { ... }`
- **Main function**: `main() -> void { ... }` (required)

### Operations
- **Arithmetic**: `+`, `-`, `*`, `/`, `%`
- **Logical**: `&&`, `||`, `!`
- **Relational**: `==`, `!=`, `>`, `<`, `>=`, `<=`
- **Unary**: `-` (negation), `!` (not)

### Control Flow
- **If-else**: `if (condition) { ... } else { ... }`
- **While loops**: `while (condition) { ... }`
- **Return**: `return value;`

### I/O
- **Print**: `print("text", variable, ...);`
- **Read**: `read(variable);`

### Special Features
- **Function calls**: Use `@` prefix: `@functionName(args)`
- **Array initialization**: `int[] arr = int[10];`
- **Array access**: `arr[index]`
- **Array length**: `length(arr)`
- **String literals**: `"Hello World"` (treated as char arrays)
- **Char literals**: `'A'`

## How to Run

### Step 1: Write Your Program
Create a `.txt` file in `Compiler_students/resources/` folder:

```
program {
    factorial(int n) -> int {
        if (n <= 1) {
            return 1;
        }
        return n * @factorial(n - 1);
    }

    main() -> void {
        int num = 5;
        int result = @factorial(num);
        print("Factorial of", num, "is", result);
    }
}
```

### Step 2: Choose Your Entry Point

#### Option A: Test Lexical Analysis Only
Run `LexerImpl.java` main method:
- Change file path to your source file
- Outputs: Token stream

#### Option B: Test Syntax Analysis
Run `ParserImpl.java` main method:
- Change file path to your source file
- Outputs: Abstract Syntax Tree (AST)

#### Option C: Run Full Compiler (RECOMMENDED)
Run `CodeGenerator.java` main method:
- Change file path to your source file (line 493)
- Outputs: Generated bytecode
- **To execute**: Uncomment line 503: `CompilerTestHelper.runVM(code);`

### Step 3: Execute the Program

In `CodeGenerator.java` main method:

```java
public static void main(String[] args) throws IOException {
    // 1. Lexical Analysis
    Lexer<TokenType> lexer = new LexerImpl(
        new SourceImpl("resources/YourFile.txt")  // ← Change this
    );

    // 2. Syntax Analysis (Parsing)
    Parser<TokenType, AST> parser = new ParserImpl(lexer);
    ProgramBodyNode root = (ProgramBodyNode) parser.entryRule();

    // 3. Semantic Analysis
    SemanticVisitor semanticVisitor = new SemanticAnalyzer();
    semanticVisitor.visit(root);
    Map<VariableNode, Symbol> map = semanticVisitor.getVarSymbolMap();

    // 4. Code Generation
    CodeGenerator codeGen = new CodeGenerator(map);
    codeGen.visit(root);
    int[] code = codeGen.getGeneratedCode();

    // 5. Display generated bytecode
    System.out.println(CompilerTestHelper.getCodeAsString(code));

    // 6. Execute on Virtual Machine (UNCOMMENT TO RUN)
    CompilerTestHelper.runVM(code);  // ← Uncomment this line
}
```

## Example Programs

### Example 1: Hello World
```
program {
    main() -> void {
        print("Hello, World!");
    }
}
```

### Example 2: Array Operations
```
program {
    main() -> void {
        int[] numbers = int[5];
        int i = 0;
        while (i < 5) {
            numbers[i] = i * 2;
            i = i + 1;
        }
        print("Array length:", length(numbers));
    }
}
```

### Example 3: Fibonacci (see resources/Fib.txt)
The Fibonacci example demonstrates:
- Functions with parameters
- Arrays
- Recursion
- Memoization
- User input with `read()`

## Compilation Stages Explained

1. **Lexer** (`LexerImpl.java`):
   - Breaks source code into tokens
   - Identifies keywords, identifiers, operators, literals

2. **Parser** (`ParserImpl.java`):
   - Builds Abstract Syntax Tree (AST)
   - Validates syntax structure
   - Implements recursive descent parsing

3. **Semantic Analyzer** (`SemanticAnalyzer.java`):
   - Type checking
   - Symbol table management
   - Scope resolution
   - Validates semantic correctness

4. **Code Generator** (`CodeGenerator.java`):
   - Generates stack-based bytecode
   - Operations similar to JVM bytecode
   - Optimizes for the custom VM

5. **Virtual Machine** (in `CompilerLib.jar`):
   - Executes generated bytecode
   - Stack-based architecture
   - Handles I/O operations

## Available Example Programs

- `Fib.txt` - Fibonacci number calculator with memoization
- `HelloWorld.txt` - Basic array and conditional operations
- `Test.txt` - Simple function call example

## Troubleshooting

### Common Errors

1. **SyntaxException**: Check your syntax matches the grammar
2. **SemanticException**: Check type mismatches, undefined variables
3. **File not found**: Use absolute path or correct relative path

### Tips
- Function names cannot be "main" (reserved)
- Function calls MUST use `@` prefix
- Arrays are 0-indexed
- All statements need semicolons except compound statements
- String literals are char arrays

## Project Structure
```
Compiler_students/
├── src/
│   ├── lexer/LexerImpl.java        - Tokenization
│   ├── parser/ParserImpl.java      - Syntax analysis
│   ├── semantics/SemanticAnalyzer.java - Type checking
│   ├── code_gen/CodeGenerator.java - Bytecode generation
│   └── token/TokenType.java        - Token definitions
├── resources/
│   ├── Fib.txt                     - Example programs
│   ├── HelloWorld.txt
│   └── Test.txt
├── grammar/
│   ├── LexGrammar.txt              - Lexical rules
│   └── ParserGrammar.txt           - Syntax rules
└── CompilerLib.jar                 - VM and utilities
```

## Quick Start

1. Open the project in IntelliJ IDEA
2. Ensure `CompilerLib.jar` is in the classpath
3. Write your program in `resources/YourProgram.txt`
4. Update the file path in `CodeGenerator.java` main method
5. Run `CodeGenerator.main()`
6. Uncomment `CompilerTestHelper.runVM(code);` to execute
7. See the output in the console!

## Language Grammar

See `grammar/ParserGrammar.txt` for the complete formal grammar specification.
